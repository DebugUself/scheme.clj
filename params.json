{
  "name": "Scheme.clj",
  "tagline": "Yet another scheme dialect written in Clojure and ClojureScript",
  "body": "Lisp is good at meta-programming, Clojure as a new dialect of Lisp, brings powers of Lisp into JVM world. [Scheme.clj](https://github.com/jiacai2050/scheme.clj/) project is my attempt to implement Scheme in Clojure(Script). It isn't a complete [R5Rs](http://www.schemers.org/Documents/Standards/R5RS/) implementation, only partial operator and feature are supported, for which you can check out [here](https://github.com/jiacai2050/scheme.clj/blob/master/src/cljc/scheme/env.cljc).\r\n\r\n## How it works\r\n\r\n### Eval-Apply cycle\r\n\r\nIn case of you not having read the wonderful book [SICP](http://mitpress.mit.edu/sicp),  I will firstly explain the famous [eval-apply cycle](http://sarabander.github.io/sicp/html/4_002e1.xhtml#g_t4_002e1_002e1).\r\n\r\n![eval-apply cycle](https://camo.githubusercontent.com/1641c36493f8543fcb60fa2c082f52abd5068f5c/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69332f3538313136363636342f5442324a68342e6b705858585862375858585858585858585858585f21213538313136363636342e706e67)\r\n\r\nEval-apply cycle is the core of every programming language:\r\n\r\n>  Expressions to be evaluated in environments are reduced to procedures to be applied to arguments, which in turn are reduced to new expressions to be evaluated in new environments, and so on, until we get down to symbols, whose values are looked up in the environment, and to primitive procedures, which are applied directly.\r\n\r\nFor example, in order to eval expression `(+ 1 2)` in global env, the evaluator will call `add` with arguments `1` and `2`, which in turns to eval symbol `+`, `1` and `2` in another env (called [closure][]); Now every expression is self-evaled, so `3` is returned as last value.\r\n\r\n## Demo\r\n\r\n```\r\n> 1\r\n1\r\n> \"hello scheme.clj\"\r\nhello scheme.clj\r\n> (+ 1 2)\r\n3\r\n> ((lambda (x y) (+ y x)) 1 2)\r\n3\r\n> (if (> 3 2) 3 2)\r\n3\r\n> (cons 1 2)\r\n#scheme.env.pair{:x 1, :y 2}\r\n> (list 1 2)\r\n(1 2)\r\n> (car (list 1 2))\r\n1\r\n> (cdr (list 1 2))\r\n(2)\r\n> (if (> 3 2) 3 2)\r\n3\r\n> (define (my-add x y) (+ y x))\r\nnil\r\n> (my-add 1 2)\r\n3\r\n> (let ((x 1) (y 2))  (my-add x y))\r\n3\r\n> (((lambda (x y) (+ x y)) 1) 2)   ;; currying\r\n3\r\n> exit\r\n```\r\n\r\n[closure]: https://en.wikipedia.org/wiki/Closure_(computer_programming)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}