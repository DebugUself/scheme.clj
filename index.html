<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Scheme.clj by jiacai2050</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="http://app.klipse.tech/css/codemirror.css">
    <script src="http://app.klipse.tech/plugin/js/klipse_plugin.js?v=3.3.1"></script>
    <script>
        window.klipse_settings = {
            selector: '.language-klipse'
        };

    </script>
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Scheme.clj</h1>
      <h2 class="project-tagline">Yet another scheme dialect written in Clojure and ClojureScript</h2>
      <a href="https://github.com/jiacai2050/scheme.clj" class="btn">View on GitHub</a>
      <a href="https://github.com/jiacai2050/scheme.clj/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jiacai2050/scheme.clj/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>Lisp is good at meta-programming, Clojure as a new dialect of Lisp, brings powers of Lisp into JVM world. <a href="https://github.com/jiacai2050/scheme.clj/">Scheme.clj</a> project is my attempt to implement Scheme in Clojure(Script). It isn't a complete <a href="http://www.schemers.org/Documents/Standards/R5RS/">R5Rs</a> implementation, only partial operator and feature are supported, for which you can check out <a href="https://github.com/jiacai2050/scheme.clj/blob/master/src/cljc/scheme/env.cljc">here</a>.</p>

<h2>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How it works</h2>

<h3>
<a id="eval-apply-cycle" class="anchor" href="#eval-apply-cycle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Eval-Apply cycle</h3>

<p>In case of you not having read the wonderful book <a href="http://mitpress.mit.edu/sicp">SICP</a>,  I will firstly explain the famous <a href="http://sarabander.github.io/sicp/html/4_002e1.xhtml#g_t4_002e1_002e1">eval-apply cycle</a>.</p>

<p><img src="https://camo.githubusercontent.com/1641c36493f8543fcb60fa2c082f52abd5068f5c/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69332f3538313136363636342f5442324a68342e6b705858585862375858585858585858585858585f21213538313136363636342e706e67" alt="eval-apply cycle"></p>

<p>Eval-apply cycle is the core of every programming language:</p>

<blockquote>
<p>Expressions to be evaluated in environments are reduced to procedures to be applied to arguments, which in turn are reduced to new expressions to be evaluated in new environments, and so on, until we get down to symbols, whose values are looked up in the environment, and to primitive procedures, which are applied directly.</p>
</blockquote>

<p>For example, in order to eval expression <code>(+ 1 2)</code> in global env, the evaluator will call <code>add</code> with arguments <code>1</code> and <code>2</code>, which in turns to eval symbol <code>+</code>, <code>1</code> and <code>2</code> in another env (called <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>); Now every expression is self-evaled, so <code>3</code> is returned as last value.</p>

<h2>
<a id="demo" class="anchor" href="#demo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Demo</h2>

<pre><code class="language-klipse" data-external-libs="https://raw.githubusercontent.com/viebel/core.match/master/src/main/clojure/,https://raw.githubusercontent.com/jiacai2050/scheme.clj/master/src/cljc/">
  (ns my.scheme
    (:require [scheme.core :refer [eval]]))
</code></pre>
<pre><code class="language-klipse">
(map eval
    ["((lambda (x y) (+ y x)) 1 22)"
     "(((lambda (x y)
                              (+ x y))
                      1)
                     20)"
     "(cons 2 3)"])
</code></pre>


      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jiacai2050/scheme.clj">Scheme.clj</a> is maintained by <a href="https://github.com/jiacai2050">jiacai2050</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>


  </body>
</html>
